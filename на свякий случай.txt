#include <iostream>
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/graphviz.hpp>
#include <boost/graph/properties.hpp>
#include <boost/property_map/property_map.hpp>
#include <boost/graph/named_function_params.hpp>
#include <boost/graph/adjacency_matrix.hpp>


#define _SCL_SECURE_NO_WARNINGS 

using std::cout;
using std::endl;

int main()
{
	//Объявили тип данных для нашего графа:
	setlocale(LC_ALL, "Russian");
	typedef boost::adjacency_list <
		boost::vecS, // как хранить вершины - в векторе
		boost::vecS, // как хранить ребра из каждой вершины - в векторе
		boost::undirectedS // неориентированный граф
	> MyGraph;


	//Заполнили рпостейший граф
	MyGraph g(2); // две вершины, для начала
	boost::write_graphviz(cout, g); // напечатать в консоль в формате graphviz
	boost::add_edge(0, 3, g); // добавить ребро. Появятся ли новые вершины?
	boost::write_graphviz(cout, g);
	auto v = boost::add_vertex(g); // добавить вершину
	cout << "Новая вершина получила номер " << v << endl;
	boost::write_graphviz(std::cout, g);


	//Добавили несколько ребер и обратимся к содержимому на низком уровне:
	boost::add_edge(0, 1, g);
	boost::add_edge(1, 3, g);
	boost::add_edge(3, 1, g);
	for (auto e : g.m_edges) {
		//g.m_edges -это std::list!
		cout << "Ребро " << e.m_source << e.m_target << endl;
	}
	for (auto w : g.m_vertices) {
		// g.m_vertices - это вектор (из-за vecS)
		// w.m_out_edges - это тоже вектор (из-за второго vecS)
		cout << "Вершина степени " << w.m_out_edges.size() << endl;
		auto it = w.m_out_edges.begin(); // итератор вектора 

		if (it != w.m_out_edges.end())  // если есть хоть одно ребро
			cout << "  Первое ребро ведёт в " << it->get_target() << endl;
	}

	//Сохраним и автоматически откроем изображение с помощью GraphViz
	std::ofstream f("graph.dot");
	boost::write_graphviz(f, g);
	f.close();
	if (!std::ifstream("graph.dot").good()) {
		std::cout << "File graph.dot does not exist or is not accessible.\n";
	}
	system("\"C:/Program Files/Graphviz/bin/dot.exe\" graph.dot -Kcirco -Tsvg -o graph.svg");
	system("start graph.svg");


	////Научимся заменять способ хранения графа. Сменим представление графа на матрицу смежности
	//typedef boost::adjacency_matrix <boost::directedS> MyGraph;
	//// ориентированный граф, неориентированные тут не поддерживаются

	//g.m_matrix[0, 2] = 1;

	//Обращение к вершинам универсальным способом
	auto vs = boost::vertices(g);
	// возвращает ПАРУ итераторов - начало и конец условного списка вершин 
	MyGraph::vertex_iterator start = vs.first, end = vs.second; // MyGraph::vertex_iterator - тип вершинного итератора
	for (MyGraph::vertex_iterator it = start; it != end; it++) { // двигаемся от начала к концу
		cout << "Из вершины " << *it << " выходит " << boost::out_degree(*it, g) << " ребер" << endl;
		// *it - тип дескриптора вершины. Обычно это её номер а для некоторых графов - указатель.
		//  boost::out_degree сам разберётся, какого типа граф g c помощью шаблонов
	}


}
